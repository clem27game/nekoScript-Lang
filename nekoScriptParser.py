# Generated from nekoScript.g4 by ANTLR 4.13.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,36,237,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,1,0,5,0,36,8,0,10,0,12,0,39,9,0,1,
        0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,52,8,1,1,2,1,2,1,2,
        1,2,1,2,1,2,3,2,60,8,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,68,8,3,1,4,1,
        4,1,4,1,4,1,4,1,4,5,4,76,8,4,10,4,12,4,79,9,4,3,4,81,8,4,1,4,1,4,
        3,4,85,8,4,1,5,1,5,1,5,1,5,1,5,3,5,92,8,5,1,6,1,6,1,6,1,6,1,6,5,
        6,99,8,6,10,6,12,6,102,9,6,1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,7,3,7,112,
        8,7,1,7,1,7,1,7,1,7,3,7,118,8,7,1,7,1,7,1,7,1,7,3,7,124,8,7,1,7,
        1,7,1,7,1,7,3,7,130,8,7,1,7,1,7,1,7,5,7,135,8,7,10,7,12,7,138,9,
        7,1,7,1,7,1,7,1,7,5,7,144,8,7,10,7,12,7,147,9,7,1,7,3,7,150,8,7,
        1,8,1,8,1,8,1,8,1,8,3,8,157,8,8,1,9,1,9,1,9,1,9,5,9,163,8,9,10,9,
        12,9,166,9,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,3,10,175,8,10,1,10,
        1,10,1,10,1,10,3,10,181,8,10,1,10,1,10,1,10,5,10,186,8,10,10,10,
        12,10,189,9,10,1,10,3,10,192,8,10,1,11,1,11,1,11,5,11,197,8,11,10,
        11,12,11,200,9,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,
        12,1,12,1,12,1,12,1,12,1,12,3,12,217,8,12,1,13,1,13,1,13,1,13,1,
        13,1,13,1,13,1,13,1,13,1,13,3,13,229,8,13,1,14,1,14,1,15,1,15,1,
        16,1,16,1,16,0,0,17,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,
        0,2,1,0,32,34,1,0,28,31,256,0,37,1,0,0,0,2,51,1,0,0,0,4,53,1,0,0,
        0,6,61,1,0,0,0,8,69,1,0,0,0,10,86,1,0,0,0,12,93,1,0,0,0,14,149,1,
        0,0,0,16,151,1,0,0,0,18,158,1,0,0,0,20,191,1,0,0,0,22,193,1,0,0,
        0,24,216,1,0,0,0,26,228,1,0,0,0,28,230,1,0,0,0,30,232,1,0,0,0,32,
        234,1,0,0,0,34,36,3,2,1,0,35,34,1,0,0,0,36,39,1,0,0,0,37,35,1,0,
        0,0,37,38,1,0,0,0,38,40,1,0,0,0,39,37,1,0,0,0,40,41,5,0,0,1,41,1,
        1,0,0,0,42,52,3,4,2,0,43,52,3,6,3,0,44,52,3,8,4,0,45,52,3,10,5,0,
        46,52,3,12,6,0,47,52,3,18,9,0,48,52,3,24,12,0,49,52,3,26,13,0,50,
        52,3,32,16,0,51,42,1,0,0,0,51,43,1,0,0,0,51,44,1,0,0,0,51,45,1,0,
        0,0,51,46,1,0,0,0,51,47,1,0,0,0,51,48,1,0,0,0,51,49,1,0,0,0,51,50,
        1,0,0,0,52,3,1,0,0,0,53,54,5,32,0,0,54,55,5,1,0,0,55,56,5,2,0,0,
        56,57,3,28,14,0,57,59,5,3,0,0,58,60,5,4,0,0,59,58,1,0,0,0,59,60,
        1,0,0,0,60,5,1,0,0,0,61,62,5,32,0,0,62,63,5,1,0,0,63,64,3,28,14,
        0,64,65,3,30,15,0,65,67,3,28,14,0,66,68,5,4,0,0,67,66,1,0,0,0,67,
        68,1,0,0,0,68,7,1,0,0,0,69,70,5,5,0,0,70,71,5,32,0,0,71,80,5,2,0,
        0,72,77,3,28,14,0,73,74,5,6,0,0,74,76,3,28,14,0,75,73,1,0,0,0,76,
        79,1,0,0,0,77,75,1,0,0,0,77,78,1,0,0,0,78,81,1,0,0,0,79,77,1,0,0,
        0,80,72,1,0,0,0,80,81,1,0,0,0,81,82,1,0,0,0,82,84,5,3,0,0,83,85,
        5,4,0,0,84,83,1,0,0,0,84,85,1,0,0,0,85,9,1,0,0,0,86,87,5,7,0,0,87,
        88,5,2,0,0,88,89,5,33,0,0,89,91,5,3,0,0,90,92,5,4,0,0,91,90,1,0,
        0,0,91,92,1,0,0,0,92,11,1,0,0,0,93,94,5,8,0,0,94,95,5,6,0,0,95,96,
        5,9,0,0,96,100,5,10,0,0,97,99,3,14,7,0,98,97,1,0,0,0,99,102,1,0,
        0,0,100,98,1,0,0,0,100,101,1,0,0,0,101,103,1,0,0,0,102,100,1,0,0,
        0,103,104,5,11,0,0,104,13,1,0,0,0,105,106,5,12,0,0,106,107,5,13,
        0,0,107,108,5,2,0,0,108,109,5,33,0,0,109,111,5,3,0,0,110,112,5,4,
        0,0,111,110,1,0,0,0,111,112,1,0,0,0,112,150,1,0,0,0,113,114,5,14,
        0,0,114,115,5,13,0,0,115,117,5,33,0,0,116,118,5,4,0,0,117,116,1,
        0,0,0,117,118,1,0,0,0,118,150,1,0,0,0,119,120,5,15,0,0,120,121,5,
        13,0,0,121,123,5,33,0,0,122,124,5,4,0,0,123,122,1,0,0,0,123,124,
        1,0,0,0,124,150,1,0,0,0,125,126,5,16,0,0,126,127,5,13,0,0,127,129,
        5,33,0,0,128,130,5,4,0,0,129,128,1,0,0,0,129,130,1,0,0,0,130,150,
        1,0,0,0,131,132,5,17,0,0,132,136,5,10,0,0,133,135,3,16,8,0,134,133,
        1,0,0,0,135,138,1,0,0,0,136,134,1,0,0,0,136,137,1,0,0,0,137,139,
        1,0,0,0,138,136,1,0,0,0,139,150,5,11,0,0,140,141,5,9,0,0,141,145,
        5,10,0,0,142,144,3,2,1,0,143,142,1,0,0,0,144,147,1,0,0,0,145,143,
        1,0,0,0,145,146,1,0,0,0,146,148,1,0,0,0,147,145,1,0,0,0,148,150,
        5,11,0,0,149,105,1,0,0,0,149,113,1,0,0,0,149,119,1,0,0,0,149,125,
        1,0,0,0,149,131,1,0,0,0,149,140,1,0,0,0,150,15,1,0,0,0,151,152,5,
        5,0,0,152,153,5,32,0,0,153,154,5,13,0,0,154,156,5,33,0,0,155,157,
        5,4,0,0,156,155,1,0,0,0,156,157,1,0,0,0,157,17,1,0,0,0,158,159,5,
        18,0,0,159,160,5,32,0,0,160,164,5,10,0,0,161,163,3,20,10,0,162,161,
        1,0,0,0,163,166,1,0,0,0,164,162,1,0,0,0,164,165,1,0,0,0,165,167,
        1,0,0,0,166,164,1,0,0,0,167,168,5,11,0,0,168,169,5,4,0,0,169,19,
        1,0,0,0,170,171,5,19,0,0,171,172,5,13,0,0,172,174,5,33,0,0,173,175,
        5,4,0,0,174,173,1,0,0,0,174,175,1,0,0,0,175,192,1,0,0,0,176,177,
        5,20,0,0,177,178,5,32,0,0,178,180,5,2,0,0,179,181,3,22,11,0,180,
        179,1,0,0,0,180,181,1,0,0,0,181,182,1,0,0,0,182,183,5,3,0,0,183,
        187,5,10,0,0,184,186,3,2,1,0,185,184,1,0,0,0,186,189,1,0,0,0,187,
        185,1,0,0,0,187,188,1,0,0,0,188,190,1,0,0,0,189,187,1,0,0,0,190,
        192,5,11,0,0,191,170,1,0,0,0,191,176,1,0,0,0,192,21,1,0,0,0,193,
        198,5,32,0,0,194,195,5,6,0,0,195,197,5,32,0,0,196,194,1,0,0,0,197,
        200,1,0,0,0,198,196,1,0,0,0,198,199,1,0,0,0,199,23,1,0,0,0,200,198,
        1,0,0,0,201,202,5,21,0,0,202,203,5,22,0,0,203,204,5,23,0,0,204,205,
        5,33,0,0,205,217,5,4,0,0,206,207,5,21,0,0,207,208,5,22,0,0,208,209,
        5,24,0,0,209,210,5,33,0,0,210,217,5,4,0,0,211,212,5,21,0,0,212,213,
        5,22,0,0,213,214,5,25,0,0,214,215,5,33,0,0,215,217,5,4,0,0,216,201,
        1,0,0,0,216,206,1,0,0,0,216,211,1,0,0,0,217,25,1,0,0,0,218,219,5,
        26,0,0,219,220,5,2,0,0,220,221,5,33,0,0,221,222,5,3,0,0,222,229,
        5,4,0,0,223,224,5,27,0,0,224,225,5,2,0,0,225,226,5,33,0,0,226,227,
        5,3,0,0,227,229,5,4,0,0,228,218,1,0,0,0,228,223,1,0,0,0,229,27,1,
        0,0,0,230,231,7,0,0,0,231,29,1,0,0,0,232,233,7,1,0,0,233,31,1,0,
        0,0,234,235,5,35,0,0,235,33,1,0,0,0,25,37,51,59,67,77,80,84,91,100,
        111,117,123,129,136,145,149,156,164,174,180,187,191,198,216,228
    ]

class nekoScriptParser ( Parser ):

    grammarFileName = "nekoScript.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'='", "'('", "')'", "';'", "'nek'", "','", 
                     "'nekImporter'", "'neksite.cr\\u00E9er'", "'script'", 
                     "'{'", "'}'", "'contenu'", "':'", "'titre'", "'lang'", 
                     "'couleur-de-fond'", "'style'", "'package'", "'dep'", 
                     "'function'", "'$'", "'neko-script'", "'publish'", 
                     "'librairie'", "'t\\u00E9l\\u00E9charger'", "'nekAppelerJs'", 
                     "'nekAppelerPython'", "'plus'", "'moins'", "'multiplier'", 
                     "'diviser'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "IDENTIFIANT", "STRING", "INT", "COMMENT", "WS" ]

    RULE_script = 0
    RULE_instruction = 1
    RULE_affectation = 2
    RULE_operation = 3
    RULE_appelFonction = 4
    RULE_importation = 5
    RULE_blocSite = 6
    RULE_contenuSite = 7
    RULE_styleInstruction = 8
    RULE_packageDeclaration = 9
    RULE_packageInstruction = 10
    RULE_paramList = 11
    RULE_terminalCommand = 12
    RULE_appelExterne = 13
    RULE_valeur = 14
    RULE_operateur = 15
    RULE_commentaire = 16

    ruleNames =  [ "script", "instruction", "affectation", "operation", 
                   "appelFonction", "importation", "blocSite", "contenuSite", 
                   "styleInstruction", "packageDeclaration", "packageInstruction", 
                   "paramList", "terminalCommand", "appelExterne", "valeur", 
                   "operateur", "commentaire" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    IDENTIFIANT=32
    STRING=33
    INT=34
    COMMENT=35
    WS=36

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ScriptContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(nekoScriptParser.EOF, 0)

        def instruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nekoScriptParser.InstructionContext)
            else:
                return self.getTypedRuleContext(nekoScriptParser.InstructionContext,i)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_script

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScript" ):
                listener.enterScript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScript" ):
                listener.exitScript(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScript" ):
                return visitor.visitScript(self)
            else:
                return visitor.visitChildren(self)




    def script(self):

        localctx = nekoScriptParser.ScriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_script)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 38858391968) != 0):
                self.state = 34
                self.instruction()
                self.state = 39
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 40
            self.match(nekoScriptParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def affectation(self):
            return self.getTypedRuleContext(nekoScriptParser.AffectationContext,0)


        def operation(self):
            return self.getTypedRuleContext(nekoScriptParser.OperationContext,0)


        def appelFonction(self):
            return self.getTypedRuleContext(nekoScriptParser.AppelFonctionContext,0)


        def importation(self):
            return self.getTypedRuleContext(nekoScriptParser.ImportationContext,0)


        def blocSite(self):
            return self.getTypedRuleContext(nekoScriptParser.BlocSiteContext,0)


        def packageDeclaration(self):
            return self.getTypedRuleContext(nekoScriptParser.PackageDeclarationContext,0)


        def terminalCommand(self):
            return self.getTypedRuleContext(nekoScriptParser.TerminalCommandContext,0)


        def appelExterne(self):
            return self.getTypedRuleContext(nekoScriptParser.AppelExterneContext,0)


        def commentaire(self):
            return self.getTypedRuleContext(nekoScriptParser.CommentaireContext,0)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruction" ):
                listener.enterInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruction" ):
                listener.exitInstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstruction" ):
                return visitor.visitInstruction(self)
            else:
                return visitor.visitChildren(self)




    def instruction(self):

        localctx = nekoScriptParser.InstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_instruction)
        try:
            self.state = 51
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 42
                self.affectation()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 43
                self.operation()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 44
                self.appelFonction()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 45
                self.importation()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 46
                self.blocSite()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 47
                self.packageDeclaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 48
                self.terminalCommand()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 49
                self.appelExterne()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 50
                self.commentaire()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AffectationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIANT(self):
            return self.getToken(nekoScriptParser.IDENTIFIANT, 0)

        def valeur(self):
            return self.getTypedRuleContext(nekoScriptParser.ValeurContext,0)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_affectation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAffectation" ):
                listener.enterAffectation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAffectation" ):
                listener.exitAffectation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAffectation" ):
                return visitor.visitAffectation(self)
            else:
                return visitor.visitChildren(self)




    def affectation(self):

        localctx = nekoScriptParser.AffectationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_affectation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.match(nekoScriptParser.IDENTIFIANT)
            self.state = 54
            self.match(nekoScriptParser.T__0)
            self.state = 55
            self.match(nekoScriptParser.T__1)
            self.state = 56
            self.valeur()
            self.state = 57
            self.match(nekoScriptParser.T__2)
            self.state = 59
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 58
                self.match(nekoScriptParser.T__3)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIANT(self):
            return self.getToken(nekoScriptParser.IDENTIFIANT, 0)

        def valeur(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nekoScriptParser.ValeurContext)
            else:
                return self.getTypedRuleContext(nekoScriptParser.ValeurContext,i)


        def operateur(self):
            return self.getTypedRuleContext(nekoScriptParser.OperateurContext,0)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperation" ):
                return visitor.visitOperation(self)
            else:
                return visitor.visitChildren(self)




    def operation(self):

        localctx = nekoScriptParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_operation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.match(nekoScriptParser.IDENTIFIANT)
            self.state = 62
            self.match(nekoScriptParser.T__0)
            self.state = 63
            self.valeur()
            self.state = 64
            self.operateur()
            self.state = 65
            self.valeur()
            self.state = 67
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 66
                self.match(nekoScriptParser.T__3)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AppelFonctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIANT(self):
            return self.getToken(nekoScriptParser.IDENTIFIANT, 0)

        def valeur(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nekoScriptParser.ValeurContext)
            else:
                return self.getTypedRuleContext(nekoScriptParser.ValeurContext,i)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_appelFonction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppelFonction" ):
                listener.enterAppelFonction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppelFonction" ):
                listener.exitAppelFonction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAppelFonction" ):
                return visitor.visitAppelFonction(self)
            else:
                return visitor.visitChildren(self)




    def appelFonction(self):

        localctx = nekoScriptParser.AppelFonctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_appelFonction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(nekoScriptParser.T__4)
            self.state = 70
            self.match(nekoScriptParser.IDENTIFIANT)
            self.state = 71
            self.match(nekoScriptParser.T__1)
            self.state = 80
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 30064771072) != 0):
                self.state = 72
                self.valeur()
                self.state = 77
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==6:
                    self.state = 73
                    self.match(nekoScriptParser.T__5)
                    self.state = 74
                    self.valeur()
                    self.state = 79
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 82
            self.match(nekoScriptParser.T__2)
            self.state = 84
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 83
                self.match(nekoScriptParser.T__3)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(nekoScriptParser.STRING, 0)

        def getRuleIndex(self):
            return nekoScriptParser.RULE_importation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportation" ):
                listener.enterImportation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportation" ):
                listener.exitImportation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportation" ):
                return visitor.visitImportation(self)
            else:
                return visitor.visitChildren(self)




    def importation(self):

        localctx = nekoScriptParser.ImportationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_importation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.match(nekoScriptParser.T__6)
            self.state = 87
            self.match(nekoScriptParser.T__1)
            self.state = 88
            self.match(nekoScriptParser.STRING)
            self.state = 89
            self.match(nekoScriptParser.T__2)
            self.state = 91
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 90
                self.match(nekoScriptParser.T__3)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlocSiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def contenuSite(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nekoScriptParser.ContenuSiteContext)
            else:
                return self.getTypedRuleContext(nekoScriptParser.ContenuSiteContext,i)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_blocSite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlocSite" ):
                listener.enterBlocSite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlocSite" ):
                listener.exitBlocSite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlocSite" ):
                return visitor.visitBlocSite(self)
            else:
                return visitor.visitChildren(self)




    def blocSite(self):

        localctx = nekoScriptParser.BlocSiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_blocSite)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.match(nekoScriptParser.T__7)
            self.state = 94
            self.match(nekoScriptParser.T__5)
            self.state = 95
            self.match(nekoScriptParser.T__8)
            self.state = 96
            self.match(nekoScriptParser.T__9)
            self.state = 100
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 250368) != 0):
                self.state = 97
                self.contenuSite()
                self.state = 102
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 103
            self.match(nekoScriptParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContenuSiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(nekoScriptParser.STRING, 0)

        def styleInstruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nekoScriptParser.StyleInstructionContext)
            else:
                return self.getTypedRuleContext(nekoScriptParser.StyleInstructionContext,i)


        def instruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nekoScriptParser.InstructionContext)
            else:
                return self.getTypedRuleContext(nekoScriptParser.InstructionContext,i)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_contenuSite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContenuSite" ):
                listener.enterContenuSite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContenuSite" ):
                listener.exitContenuSite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContenuSite" ):
                return visitor.visitContenuSite(self)
            else:
                return visitor.visitChildren(self)




    def contenuSite(self):

        localctx = nekoScriptParser.ContenuSiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_contenuSite)
        self._la = 0 # Token type
        try:
            self.state = 149
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [12]:
                self.enterOuterAlt(localctx, 1)
                self.state = 105
                self.match(nekoScriptParser.T__11)
                self.state = 106
                self.match(nekoScriptParser.T__12)
                self.state = 107
                self.match(nekoScriptParser.T__1)
                self.state = 108
                self.match(nekoScriptParser.STRING)
                self.state = 109
                self.match(nekoScriptParser.T__2)
                self.state = 111
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 110
                    self.match(nekoScriptParser.T__3)


                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 2)
                self.state = 113
                self.match(nekoScriptParser.T__13)
                self.state = 114
                self.match(nekoScriptParser.T__12)
                self.state = 115
                self.match(nekoScriptParser.STRING)
                self.state = 117
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 116
                    self.match(nekoScriptParser.T__3)


                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 3)
                self.state = 119
                self.match(nekoScriptParser.T__14)
                self.state = 120
                self.match(nekoScriptParser.T__12)
                self.state = 121
                self.match(nekoScriptParser.STRING)
                self.state = 123
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 122
                    self.match(nekoScriptParser.T__3)


                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 4)
                self.state = 125
                self.match(nekoScriptParser.T__15)
                self.state = 126
                self.match(nekoScriptParser.T__12)
                self.state = 127
                self.match(nekoScriptParser.STRING)
                self.state = 129
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 128
                    self.match(nekoScriptParser.T__3)


                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 5)
                self.state = 131
                self.match(nekoScriptParser.T__16)
                self.state = 132
                self.match(nekoScriptParser.T__9)
                self.state = 136
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 133
                    self.styleInstruction()
                    self.state = 138
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 139
                self.match(nekoScriptParser.T__10)
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 6)
                self.state = 140
                self.match(nekoScriptParser.T__8)
                self.state = 141
                self.match(nekoScriptParser.T__9)
                self.state = 145
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 38858391968) != 0):
                    self.state = 142
                    self.instruction()
                    self.state = 147
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 148
                self.match(nekoScriptParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StyleInstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIANT(self):
            return self.getToken(nekoScriptParser.IDENTIFIANT, 0)

        def STRING(self):
            return self.getToken(nekoScriptParser.STRING, 0)

        def getRuleIndex(self):
            return nekoScriptParser.RULE_styleInstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStyleInstruction" ):
                listener.enterStyleInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStyleInstruction" ):
                listener.exitStyleInstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStyleInstruction" ):
                return visitor.visitStyleInstruction(self)
            else:
                return visitor.visitChildren(self)




    def styleInstruction(self):

        localctx = nekoScriptParser.StyleInstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_styleInstruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(nekoScriptParser.T__4)
            self.state = 152
            self.match(nekoScriptParser.IDENTIFIANT)
            self.state = 153
            self.match(nekoScriptParser.T__12)
            self.state = 154
            self.match(nekoScriptParser.STRING)
            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 155
                self.match(nekoScriptParser.T__3)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PackageDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIANT(self):
            return self.getToken(nekoScriptParser.IDENTIFIANT, 0)

        def packageInstruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nekoScriptParser.PackageInstructionContext)
            else:
                return self.getTypedRuleContext(nekoScriptParser.PackageInstructionContext,i)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_packageDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackageDeclaration" ):
                listener.enterPackageDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackageDeclaration" ):
                listener.exitPackageDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackageDeclaration" ):
                return visitor.visitPackageDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def packageDeclaration(self):

        localctx = nekoScriptParser.PackageDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_packageDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(nekoScriptParser.T__17)
            self.state = 159
            self.match(nekoScriptParser.IDENTIFIANT)
            self.state = 160
            self.match(nekoScriptParser.T__9)
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==19 or _la==20:
                self.state = 161
                self.packageInstruction()
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 167
            self.match(nekoScriptParser.T__10)
            self.state = 168
            self.match(nekoScriptParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PackageInstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(nekoScriptParser.STRING, 0)

        def IDENTIFIANT(self):
            return self.getToken(nekoScriptParser.IDENTIFIANT, 0)

        def paramList(self):
            return self.getTypedRuleContext(nekoScriptParser.ParamListContext,0)


        def instruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nekoScriptParser.InstructionContext)
            else:
                return self.getTypedRuleContext(nekoScriptParser.InstructionContext,i)


        def getRuleIndex(self):
            return nekoScriptParser.RULE_packageInstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPackageInstruction" ):
                listener.enterPackageInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPackageInstruction" ):
                listener.exitPackageInstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPackageInstruction" ):
                return visitor.visitPackageInstruction(self)
            else:
                return visitor.visitChildren(self)




    def packageInstruction(self):

        localctx = nekoScriptParser.PackageInstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_packageInstruction)
        self._la = 0 # Token type
        try:
            self.state = 191
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19]:
                self.enterOuterAlt(localctx, 1)
                self.state = 170
                self.match(nekoScriptParser.T__18)
                self.state = 171
                self.match(nekoScriptParser.T__12)
                self.state = 172
                self.match(nekoScriptParser.STRING)
                self.state = 174
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 173
                    self.match(nekoScriptParser.T__3)


                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 2)
                self.state = 176
                self.match(nekoScriptParser.T__19)
                self.state = 177
                self.match(nekoScriptParser.IDENTIFIANT)
                self.state = 178
                self.match(nekoScriptParser.T__1)
                self.state = 180
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==32:
                    self.state = 179
                    self.paramList()


                self.state = 182
                self.match(nekoScriptParser.T__2)
                self.state = 183
                self.match(nekoScriptParser.T__9)
                self.state = 187
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 38858391968) != 0):
                    self.state = 184
                    self.instruction()
                    self.state = 189
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 190
                self.match(nekoScriptParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIANT(self, i:int=None):
            if i is None:
                return self.getTokens(nekoScriptParser.IDENTIFIANT)
            else:
                return self.getToken(nekoScriptParser.IDENTIFIANT, i)

        def getRuleIndex(self):
            return nekoScriptParser.RULE_paramList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamList" ):
                listener.enterParamList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamList" ):
                listener.exitParamList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamList" ):
                return visitor.visitParamList(self)
            else:
                return visitor.visitChildren(self)




    def paramList(self):

        localctx = nekoScriptParser.ParamListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_paramList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(nekoScriptParser.IDENTIFIANT)
            self.state = 198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==6:
                self.state = 194
                self.match(nekoScriptParser.T__5)
                self.state = 195
                self.match(nekoScriptParser.IDENTIFIANT)
                self.state = 200
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TerminalCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(nekoScriptParser.STRING, 0)

        def getRuleIndex(self):
            return nekoScriptParser.RULE_terminalCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerminalCommand" ):
                listener.enterTerminalCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerminalCommand" ):
                listener.exitTerminalCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerminalCommand" ):
                return visitor.visitTerminalCommand(self)
            else:
                return visitor.visitChildren(self)




    def terminalCommand(self):

        localctx = nekoScriptParser.TerminalCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_terminalCommand)
        try:
            self.state = 216
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 201
                self.match(nekoScriptParser.T__20)
                self.state = 202
                self.match(nekoScriptParser.T__21)
                self.state = 203
                self.match(nekoScriptParser.T__22)
                self.state = 204
                self.match(nekoScriptParser.STRING)
                self.state = 205
                self.match(nekoScriptParser.T__3)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 206
                self.match(nekoScriptParser.T__20)
                self.state = 207
                self.match(nekoScriptParser.T__21)
                self.state = 208
                self.match(nekoScriptParser.T__23)
                self.state = 209
                self.match(nekoScriptParser.STRING)
                self.state = 210
                self.match(nekoScriptParser.T__3)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 211
                self.match(nekoScriptParser.T__20)
                self.state = 212
                self.match(nekoScriptParser.T__21)
                self.state = 213
                self.match(nekoScriptParser.T__24)
                self.state = 214
                self.match(nekoScriptParser.STRING)
                self.state = 215
                self.match(nekoScriptParser.T__3)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AppelExterneContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(nekoScriptParser.STRING, 0)

        def getRuleIndex(self):
            return nekoScriptParser.RULE_appelExterne

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppelExterne" ):
                listener.enterAppelExterne(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppelExterne" ):
                listener.exitAppelExterne(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAppelExterne" ):
                return visitor.visitAppelExterne(self)
            else:
                return visitor.visitChildren(self)




    def appelExterne(self):

        localctx = nekoScriptParser.AppelExterneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_appelExterne)
        try:
            self.state = 228
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26]:
                self.enterOuterAlt(localctx, 1)
                self.state = 218
                self.match(nekoScriptParser.T__25)
                self.state = 219
                self.match(nekoScriptParser.T__1)
                self.state = 220
                self.match(nekoScriptParser.STRING)
                self.state = 221
                self.match(nekoScriptParser.T__2)
                self.state = 222
                self.match(nekoScriptParser.T__3)
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 2)
                self.state = 223
                self.match(nekoScriptParser.T__26)
                self.state = 224
                self.match(nekoScriptParser.T__1)
                self.state = 225
                self.match(nekoScriptParser.STRING)
                self.state = 226
                self.match(nekoScriptParser.T__2)
                self.state = 227
                self.match(nekoScriptParser.T__3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValeurContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(nekoScriptParser.STRING, 0)

        def INT(self):
            return self.getToken(nekoScriptParser.INT, 0)

        def IDENTIFIANT(self):
            return self.getToken(nekoScriptParser.IDENTIFIANT, 0)

        def getRuleIndex(self):
            return nekoScriptParser.RULE_valeur

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValeur" ):
                listener.enterValeur(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValeur" ):
                listener.exitValeur(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValeur" ):
                return visitor.visitValeur(self)
            else:
                return visitor.visitChildren(self)




    def valeur(self):

        localctx = nekoScriptParser.ValeurContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_valeur)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 30064771072) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperateurContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nekoScriptParser.RULE_operateur

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperateur" ):
                listener.enterOperateur(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperateur" ):
                listener.exitOperateur(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperateur" ):
                return visitor.visitOperateur(self)
            else:
                return visitor.visitChildren(self)




    def operateur(self):

        localctx = nekoScriptParser.OperateurContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_operateur)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4026531840) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentaireContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(nekoScriptParser.COMMENT, 0)

        def getRuleIndex(self):
            return nekoScriptParser.RULE_commentaire

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommentaire" ):
                listener.enterCommentaire(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommentaire" ):
                listener.exitCommentaire(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommentaire" ):
                return visitor.visitCommentaire(self)
            else:
                return visitor.visitChildren(self)




    def commentaire(self):

        localctx = nekoScriptParser.CommentaireContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_commentaire)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            self.match(nekoScriptParser.COMMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





